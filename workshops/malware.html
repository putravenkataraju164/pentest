<!doctype html>
<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title></title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="../pkg/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
	mark {
	  background-color: #52BE80;
	}
  </style>
  <script src="../gif/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../gif/gif-player.es5.js" defer async></script>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="re101"
                  title="Malware Analysis"
                  environment="web"
                  feedback-link="">


      <google-codelab-step label="Intro" duration="5">
			<h2 is-upgraded>Malware Analysis</h2>
      <p>Malware analysis is the art of dissecting malware to understand how its works, how to identify it, and how to defeat or eliminate it. And you don’t need to be an uber-hacker to perform malware analysis.</p>
      <h2 is-upgraded>Prerequisites</h2>
			<ul>
			<li>Information Security Basics</li>
			<li>Basic Knowledge in Networking</li>
			<li>Familiar with Windows and Linux OS</li>
			<li>Programming knowledge in Assembly language and C language</li>
			</ul>
			<h2 is-upgraded>What you&#39;ll learn</h2>
			<ul class="checklist">
			<li>Different Malware Analysis Techniques</li>
			<li>How to use Anti-disassembly and Anti-debugging or packing techniques</li>
			<li>Practical Malware Analysis and Reverse Engineering</li>
			<li>Working with various MA and RE Tools</li>
			</ul>
      </google-codelab-step>
      <google-codelab-step label="Malware Analysis Premier" duration="30">
			<ul>
      <li>The purpose  of <code>malware analysis</code> is usually to provide the information you need to respond to a network intrusion.</li>
      <li>Your goals will typically be to determine exactly what happened, and to ensure that you’ve located all infected machines and files.</li>
      <li>When analyzing suspected malware, your goal will typically be to determine exactly what a particular suspect binary can do, how to detect it on your network, and how to measure and contain its damage.</li>
      <li>Once you identify which files require full analysis, it’s time to develop signatures to detect malware infections on your network</li>
      </ul>
      <h2 is-upgraded>Signatures / Indicators</h2>
      <p>Malware analysis can be used to develop <code>host-based</code> and <code>network signatures</code>.</p>
      <ul>
      <li><b>Host-based signatures</b> are used to detect malicious code on victim computers. These indicators often identify files created or modified by the malware or specific changes that it makes to the registry.</li>
      <aside class="special">Unlike antivirus signatures, malware indicators focus on what the malware does to a system, not on the characteristics of the malware itself, which makes them more effective in detecting malware that changes form or that has been deleted from the hard disk.</aside>
      <li><b>Network signatures</b> are used to detect malicious code by monitoring network traffic. Network signatures can be created without malware analysis, but signatures created with the help of malware analysis are usually far more effective, offering a higher detection rate and fewer false positives</li>
      </ul>
      <h2 is-upgraded>Malware Analysis Techniques</h2>
      <p>There are two fundamental approaches to malware analysis: <code>static</code> and <code>dynamic</code>. Both static and dynamic are further categorized as <code>basic</code> or <code>advanced</code>.</p>
      <ol>
        <pre><code>Static analysis involves examining the malware without running it.<br>Dynamic analysis involves running the malware.</code></pre>
        <li><b>Basic static analysis</b> consists of examining the executable file without viewing the actual instructions. Basic static analysis can confirm whether a file is malicious, provide information about its functionality, and sometimes provide information that will allow you to produce simple network signatures. </li>
        <li><b>Basic dynamic analysis</b> techniques involve running the malware and observing its behavior on the system in order to remove the infection, produce effective signatures, or both.</li>
          <aside class="special">Basic dynamic analysis techniques can be used by most people without deep programming knowledge, but they won’t be effective with all malware and can miss important functionality.</aside>
        <li><b>Advanced static analysis</b> consists of reverse-engineering the malware’s internals by loading the executable into a disassembler and looking at the program instructions in order to discover what the program does. The instructions are executed by the CPU.</li>
        <li><b>Advanced dynamic analysis</b> uses a debugger to examine the internal state of a running malicious executable. It provide another way to extract detailed information from an executable.</li>
          <aside class="special">Advance techniques are most useful when you’re trying to obtain information that is difficult to gather with the other techniques.</aside>
      </ol>
      <pre><code>Before you can run malware safely, you must set up an environment that will allow you to study the running malware without risk of damage to your system or network.</code></pre>
      </google-codelab-step>
      <google-codelab-step label="Types of Malware" duration="15">
        <table>
      <tr><td colspan="1" rowspan="1"><p><strong>Type</strong></p>
      </td><td colspan="1" rowspan="1"><p><strong>Description</strong></p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>Virus</strong></p>
      </td><td colspan="1" rowspan="1"><p>Code that propagates (replicates) across systems with user intervention</p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>Worm</strong></p>
      </td><td colspan="1" rowspan="1"><p>Code that self-propagates/replicates across systems without requiring user intervention</p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>Bot</strong></p>
      </td><td colspan="1" rowspan="1"><p>Automated process that interacts with other network services</p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>Trojan</strong></p>
      </td><td colspan="1" rowspan="1"><p>Malware that is often disguised as legitimate software</p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>Ransomware</strong></p>
      </td><td colspan="1" rowspan="1"><p>Malware that holds the victim&#39;s data hostage by cryptography or other means</p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>Rootkit</strong></p>
      </td><td colspan="1" rowspan="1"><p>Masks its existence or the existence of other software</p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>Backdoor</strong></p>
      </td><td colspan="1" rowspan="1"><p>Enables a remote attacker to have access to or send commands to a compromised computer</p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>RAT</strong></p>
      </td><td colspan="1" rowspan="1"><p>Remote Access Trojan, similar to a backdoor</p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>Info Stealer</strong></p>
      </td><td colspan="1" rowspan="1"><p>Steals victims information, passwords, or other personal data</p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>HackTool</strong></p>
      </td><td colspan="1" rowspan="1"><p>Admin tools or programs that may be used by hackers to attack computer systems and networks. These programs are not generally malicious</p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>Hoax</strong></p>
      </td><td colspan="1" rowspan="1"><p>Program may deliver a false warning about a computer virus or install a fake AV</p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>Dropper/Downloader</strong></p>
      </td><td colspan="1" rowspan="1"><p>Designed to &#34;install&#34; or download some sort of malware</p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>Adware</strong></p>
      </td><td colspan="1" rowspan="1"><p>Automatically renders advertisements in order to generate revenue for its author.</p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>PUP/PUA</strong></p>
      </td><td colspan="1" rowspan="1"><p>Potentially Unwanted Program, sometimes added to a system without the user&#39;s knowledge or approval</p>
      </td></tr>
      </table>
     <aside class="special">Malware often spans multiple categories. For example, a program might have a keylogger that collects passwords and a worm component that sends spam.</aside>
     </google-codelab-step>
     <google-codelab-step label="Portable Executable (PE)" duration="60">
      <p>Portable Executable (PE) file format is used by Windows executables, object code, and DLLs. The PE file format is a data structure that contains the information necessary for the Windows OS loader to manage the wrapped executable code.</p>
      <ul>
        <li> Nearly every file with executable code that is loaded by Windows is in the PE file format, though some legacy file formats do appear on rare occasion in malware. </li>
        <li>PE files begin with a header that includes information about the code, the type of application, required library functions, and space requirements. The information in the PE header is of great value to the malware analyst.</li>
      </ul>
      <h2 is-upgraded>PE File Headers and Sections</h2>
      <p>The PE file format contains a header followed by a series of sections. The header contains metadata about the file itself. Following the header are the actual sections of the file, each of which contains useful information.</p>
      <p class="image-container"><img src="../mal/pe.png" alt="PE Contents"></p>
      <table>
      <tr><td colspan="1" rowspan="1"><p><strong>Section</strong></p>
      </td><td colspan="1" rowspan="1"><p><strong>Description</strong></p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>.text</strong></p>
      </td><td colspan="1" rowspan="1"><p>Contains the executable code, instructions to the CPU</p>
      <tr><td colspan="1" rowspan="1"><p><strong>.rdata</strong></p>
      </td><td colspan="1" rowspan="1"><p>Holds read-only data that is globally accessible within the program, import and export information </p>
      <tr><td colspan="1" rowspan="1"><p><strong>.data</strong></p>
      </td><td colspan="1" rowspan="1"><p>Stores global data accessed throughout the program, which is accessible from anywhere in the program. </p>
      <tr><td colspan="1" rowspan="1"><p><strong>.idata</strong></p>
      </td><td colspan="1" rowspan="1"><p>Sometimes present and stores the import function information; if this section is not present, the import function information is stored in the .rdata section</p>
      <tr><td colspan="1" rowspan="1"><p><strong>.edata</strong></p>
      </td><td colspan="1" rowspan="1"><p>Sometimes present and stores the export function information; if this section is not present, the export function information is stored in the .rdata section</p>
      <tr><td colspan="1" rowspan="1"><p><strong>.pdata</strong></p>
      </td><td colspan="1" rowspan="1"><p>Present only in 64-bit executables and stores exception-handling information</p>
      <tr><td colspan="1" rowspan="1"><p><strong>.rsrc</strong></p>
      </td><td colspan="1" rowspan="1"><p>Stores resources needed by the executable</p>
      <tr><td colspan="1" rowspan="1"><p><strong>.reloc</strong></p>
      </td><td colspan="1" rowspan="1"><p>Contains information for relocation of library files</p>
      </td></tr>
      </table>
      <h2 is-upgraded>Functions</h2>
      <ul>
        <li>Imports are functions used by one program that are actually stored in a different program, such as code libraries that contain functionality common to many programs. Code libraries can be connected to the main executable by <code>linking</code>.</li>
        <aside class="special">Programmers link imports to their programs so that they don’t need to re-implement certain functionality in multiple programs. Code libraries can be linked statically, at runtime, or dynamically</aside>
        <li>Exports are functions in the malware that are meant to be called by other programs or libraries</li>
      </ul>
      <h2 is-upgraded>Linked Libraries</h2>
      <ul>
        <li><b>Static linking</b> is the least commonly used method of linking libraries (it is common in UNIX and Linux programs). When a library is statically linked to an executable, all code from that library is copied into the executable, which makes the executable grow in size.</li>
        <li><b>Runtime linking</b> is commonly used in malware, especially when it’s <code>packed</code> or <code>obfuscated</code>. Executables that use runtime linking connect to libraries only when that function is needed.</li>
        <li><b>Dynamic linking</b> in which all the libraries are linked at program start.</li>
      </ul>
      <table><b>Common DLLs</b>
      <tr><td colspan="1" rowspan="1"><p><strong>DLL</strong></p>
      </td><td colspan="1" rowspan="1"><p><strong>Description</strong></p>
      </td></tr>
      <tr><td colspan="1" rowspan="1"><p><strong>Kernel32.dll</strong></p>
      </td><td colspan="1" rowspan="1"><p>This is a very common DLL that contains core functionality, such as access and manipulation of memory, files, and hardware.</p>
      <tr><td colspan="1" rowspan="1"><p><strong>Advapi32.dll</strong></p>
      </td><td colspan="1" rowspan="1"><p>This DLL provides access to advanced core Windows components such as the Service Manager and Registry.</p>
      <tr><td colspan="1" rowspan="1"><p><strong>User32.dll</strong></p>
      </td><td colspan="1" rowspan="1"><p>This DLL contains all the user-interface components, such as buttons, scroll bars, and components for controlling and responding to user actions.</p>
      <tr><td colspan="1" rowspan="1"><p><strong>Gdi32.dll</strong></p>
      </td><td colspan="1" rowspan="1"><p>This DLL contains functions for displaying and manipulating graphics.</p>
      <tr><td colspan="1" rowspan="1"><p><strong>Ntdll.dll</strong></p>
      </td><td colspan="1" rowspan="1"><p>This DLL is the interface to the Windows kernel. Executables generally do not import this file directly, although it is always imported indirectly by Kernel32.dll. If an executable imports this file, it means that the author intended to use functionality not normally available to Windows programs. Some tasks, such as hiding functionality or manipulating processes, will use this interface.</p>
      <tr><td colspan="1" rowspan="1"><p><strong>WSock32.dll and Ws2_32.dll</strong></p>
      </td><td colspan="1" rowspan="1"><p>These are networking DLLs. A program that accesses either of these most likely connects to a network or performs network-related tasks.</p>
      <tr><td colspan="1" rowspan="1"><p><strong>Wininet.dll</strong></p>
      </td><td colspan="1" rowspan="1"><p>This DLL contains higher-level networking functions that implement protocols such as FTP, HTTP, and NTP.</p>
      </td></tr>
      </table>
      <h2 is-upgraded>Obfuscated and Packed Malware</h2>
      <p>Malware writers often use packing or obfuscation to make their files more difficult to detect or analyze.</p>
      <ul>
        <li><b>Obfuscated</b> programs are ones whose execution the malware author has attempted to hide, not understandable.</li>
      </ul>
        <p><b>Example:</b> obfuscation</p>
<table>
<tr>
<td><b>Javascript code</b><pre><code style="background-color:#28323f;">
function hi() {
  console.log("Hello World!");
  }
hi();
          </pre></code></td>
          <td><b>Obfuscated Javascript code</b><pre><code style="background-color:#28323f;">
var _0xd02c=[
"\x48\x65\x6C\x6C\x6F\x20\x57\x6F\x72\x6C\x64\x21",
"\x6C\x6F\x67"
];
function hi(){
  console[_0xd02c[1]](_0xd02c[0])
}
hi()
</pre></code></td>
</tr>
</table>
      <ul>
        <li><b>Packing</b> programs are a subset of obfuscated programs in which the malicious program is compressed and cannot be analyzed </li>
      </ul>
       <p class="image-container"><img src="../mal/pack_unpack.png" alt="Packed Malware"></p>
      <aside class="special">Both techniques will severely limit your attempts to statically analyze the malware.</aside>

     </google-codelab-step>
     <google-codelab-step label="Environment Setup" duration="30">
       <p>Malware Analyst should be very careful while performing analysis, since malwares easily gets systems and networks infected we should setup a safe environment. In this workshop we are going to use Flare VM developed by <a href="https://www.fireeye.com/blog/threat-research/2017/07/flare-vm-the-windows-malware.html">Fireeye</a> cyber security experts.</p>
       <ul>
       <li>FLARE VM is a freely available and open sourced Windows-based security distribution designed for reverse engineers, malware analysts, incident responders, forensicators, and penetration testers. Inspired by open-source Linux-based security distributions like Kali Linux, REMnux and others</li>
       <li>FLARE VM delivers a fully configured platform with a comprehensive collection of Windows security tools such as debuggers, disassemblers, decompilers, static and dynamic analysis utilities, network analysis and manipulation, web assessment, exploitation, vulnerability assessment applications, and many others.</li>
       <li>The distribution also includes the FLARE team’s public malware analysis tools such as FLOSS and FakeNet-NG.</li>
       </ul>
      <aside class="special">In this section you will be setting up a safe virtual malware analysis environment. The virtual machine (VM) that you will be running the malware on should not have internet access nor network share access to the host system.</aside>
      <h2 is-upgraded>Installing VirtualBox</h2>
      <p>Click the icons below to download the version of Virtualbox for your OS.</p>
      <table>
      <tr><td colspan="1" rowspan="1"><p><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank"><paper-button class="colored" raised>Windows VirtualBox</paper-button></a></p>
      </td><td colspan="1" rowspan="1"><p><a href="https://www.virtualbox.org/wiki/Linux_Downloads" target="_blank"><paper-button class="colored" raised>Linux VirtualBox</paper-button></a></p>
      </td><td colspan="1" rowspan="1"><p><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank"><paper-button class="colored" raised>MacOS VirtualBox</paper-button></a></p>
      </td></tr>
      </table>
      <h2 is-upgraded>Download VM Directly</h2>
      <p><center><a href="#" target="_blank"><paper-button class="colored" raised>MARE VM ZIP</paper-button></a></center></p>
      <p><center><code>OR</code></center></p>
      <h2 is-upgraded>Manual Setup instructions</h2>
      <h3>Install Windows 7 in Virtual Box</h3>
      <pre><code>Do not forget to install "Virtual Box Guest Additions" and Take 1st snapshot</code></pre>
      <aside class="special">Goto <code>Machine</code> tab and then select <code>Take Snapshot</code> to take a snapshot of current windows state</aside>
      <h3>Installing Flare VM Tools</h3>
      <table>
      <tr><td colspan="1" rowspan="1"><p><a href="https://www.fireeye.com/blog/threat-research/2018/11/flare-vm-update.html" target="_blank"><paper-button class="colored" raised>Fireeye Setup</paper-button></a></p>
      </td><td colspan="1" rowspan="1"><p><a href="https://github.com/fireeye/flare-vm" target="_blank"><paper-button class="colored" raised>Fireeye Github Repo</paper-button></a></p>
      </td></tr>
      </table>
      <ol><b>Flare VM installation process</b>
        <li>Download the Flarevm github repository from above link in Windows 7 VM</li>
        <li>Open <code>powershell</code> as administrator and Change execution policy to Unrestricted <code>Set-ExecutionPolicy Unrestricted</code></li>
        <li>Navigate to flarevm repository and run the <code>.\install.ps1</code> from powershell, enter windows password when prompted</li>
      </ol>
      <pre><code>After installation of Flare VM tools take 2nd snapshot</pre></code>
    </google-codelab-step>
    <google-codelab-step label="Basic Static Analysis" duration="40">
      <p>Basic static analysis consists of examining the executable file without viewing the actual instructions. Basic static analysis can confirm whether a file is malicious, provide information about its functionality, and sometimes provide information that will allow you to produce simple network signatures.</p>
      <aside class="special">Static analysis describes the process of analyzing the code or structure of a program to determine its function. The program itself is not run at this time</aside>
      <ul>
      <li>Using antivirus tools to confirm maliciousness</li>
      <li>Using hashes to identify malware</li>
      <li>Gleaning information from a file’s strings, functions, and headers</li>
      </ul>
    <h3>Antivirus Scanning</h3>
    <p>First step for analysing a malware is to run it through multiple antivirus programs, which may already have identified it.</p>
    <p>But antivirus tools are certainly not perfect. They rely mainly on a database of identifiable pieces of known suspicious code using <code>file signatures</code>, as well as behavioral and pattern-matching analysis to identify suspect files.</p>
    <aside class="special">Malware writers can easily modify their code, thereby changing their program’s signature and evading virus scanners. Also, rare malware often goes undetected by antivirus software because it’s simply not in the database.</aside>
    <p> VirusTotal (<a href="http://www.virustotal.com/" target="_blank">http://www.virustotal.com/</a>) allow you to upload a file for scanning by multiple antivirus engines. It aslo generates a report that provides the total number of engines that marked the file as malicious, the malware name, and, if available, additional information about the malware.</p>
    <h3>Hashing</h3>
    <p>Hashing is a common method used to uniquely identify malware. The malicious software is run through a hashing program that produces a unique hash that identifies that malware (a sort of fingerprint).</p>
    <p>The Message-Digest Algorithm 5 (MD5) hash function is the one most commonly used for malware analysis, though the Secure Hash Algorithm 1 (SHA-1) is also popular.</p>
    <ul>Once you have a unique hash for a piece of malware, you can use it as follows:
    <li>Use the hash as a label.</li>
    <li>Share that hash with other analysts to help them to identify malware.</li>
    <li>Search for that hash online to see if the file has already been identified.</li>
    </ul>
    <h3>Finding strings</h3>
    <p>A string in a program is a sequence of characters such as “the.” A program contains strings if it prints a message, connects to a URL, or copies a file to a specific location.</p>
    <p>Searching through the strings can be a simple way to get hints about the functionality of a program.</p>
    <aside class="special"><b>Example:</b> If the program accesses a URL, then you will see the URL accessed stored as a string in the program. You can use the <a href="http://bit.ly/ic4plL" target="_blank">Strings</a> program, to search an executable for strings, which are typically stored in either ASCII or Unicode format.</aside>
    <h3>Examining PE Files</h3>
    <p>The PE file format stores interesting information within its header. We can use the <a href="https://www.aldeid.com/wiki/PEView" target="_blank"> PEview tool</a> to browse through the information</p>
    <h3>Detecting Packers</h3>
    <p>Identify if the malware is packed with the help of <a href="https://www.aldeid.com/wiki/PEiD" target="_blank">PEiD program</a>. PEiD identifies the type of packer or compiler employed to build an application, which makes analyzing the packed file much easier.</p>
    <p>If a program is packed, you must unpack it in order to be able to perform any analysis.</p>
    <h3>Exploring Libraries and Functions</h3>
    <p>The PE file header stores information about every library that will be loaded and every function that will be used by the program. </p>
    <p>The libraries used and functions called are often the most important parts of a program, and identifying them is particularly important, because it allows us to guess at what the program does.</p>
    <p>The <a href="http://www.dependencywalker.com/" target="_black">Dependency Walker</a> program, is used to find the libraries and functions.</p>
    <h3>Viewing the Resource Section</h3>
    <p>We can use the free Resource Hacker tool found at http://www.angusj.com/ to browse the .rsrc section.</p>
    <p>When you click through the items in Resource Hacker, you’ll see the strings, icons, and menus. The menus displayed are identical to what the program uses.</p>
    <ul>The informative sections for malware analysis include:
      <li>The Icon section lists images shown when the executable is in a file listing.</li>
      <li>The Menu section stores all menus that appear in various windows, such as the File, Edit, and View menus. This section contains the names of all the menus, as well as the text shown for each. The names should give you a good idea of their functionality.</li>
      <li>The Dialog section contains the program’s dialog menus. The dialog at shows what the user will see when running calc.exe. If we knew nothing else about calc.exe, we could identify it as a calculator program simply by looking at this dialog menu.</li>
      <li>The String Table section stores strings.</li>
      <li>The Version Info section contains a version number and often the company name and a copyright statement.</li>
      <p>The .rsrc section shown in image is typical of Windows applications and can include whatever a programmer requires.</p>
    </ul>
    </google-codelab-step>
    <google-codelab-step label="Basic Dynamic Analysis" duration="40">

    </google-codelab-step>
  </google-codelab>
  <script src="../pkg/native-shim.js"></script>
  <script src="../pkg/custom-elements.min.js"></script>
  <script src="../pkg/prettify.js"></script>
  <script src="../pkg/codelab-elements.js"></script>


</body>
</html>
